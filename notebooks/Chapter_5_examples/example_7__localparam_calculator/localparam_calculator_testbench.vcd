$version Generated by VerilatedVcd $end
$timescale 1ps $end
 $scope module $rootio $end
 $upscope $end
 $scope module localparam_calculator_testbench $end
  $var wire 1 & clk $end
  $var wire 1 ' reset $end
  $scope module default_calc $end
   $var wire 32 ( DATA_WIDTH [31:0] $end
   $var wire 32 ) NUM_ELEMENTS [31:0] $end
   $var wire 1 & clk $end
   $var wire 1 ' reset $end
   $var wire 32 * ADDR_WIDTH [31:0] $end
   $var wire 32 + TOTAL_BITS [31:0] $end
   $var wire 32 , MAX_VALUE [31:0] $end
   $var wire 32 ( HALF_ELEMENTS [31:0] $end
   $var wire 8 - memory[0] [7:0] $end
   $var wire 8 . memory[1] [7:0] $end
   $var wire 8 / memory[2] [7:0] $end
   $var wire 8 0 memory[3] [7:0] $end
   $var wire 8 1 memory[4] [7:0] $end
   $var wire 8 2 memory[5] [7:0] $end
   $var wire 8 3 memory[6] [7:0] $end
   $var wire 8 4 memory[7] [7:0] $end
   $var wire 8 5 memory[8] [7:0] $end
   $var wire 8 6 memory[9] [7:0] $end
   $var wire 8 7 memory[10] [7:0] $end
   $var wire 8 8 memory[11] [7:0] $end
   $var wire 8 9 memory[12] [7:0] $end
   $var wire 8 : memory[13] [7:0] $end
   $var wire 8 ; memory[14] [7:0] $end
   $var wire 8 < memory[15] [7:0] $end
   $var wire 4 # address [3:0] $end
  $upscope $end
  $scope module small_wide_calc $end
   $var wire 32 * DATA_WIDTH [31:0] $end
   $var wire 32 = NUM_ELEMENTS [31:0] $end
   $var wire 1 & clk $end
   $var wire 1 ' reset $end
   $var wire 32 > ADDR_WIDTH [31:0] $end
   $var wire 32 + TOTAL_BITS [31:0] $end
   $var wire 32 ? MAX_VALUE [31:0] $end
   $var wire 32 ) HALF_ELEMENTS [31:0] $end
   $var wire 4 @ memory[0] [3:0] $end
   $var wire 4 A memory[1] [3:0] $end
   $var wire 4 B memory[2] [3:0] $end
   $var wire 4 C memory[3] [3:0] $end
   $var wire 4 D memory[4] [3:0] $end
   $var wire 4 E memory[5] [3:0] $end
   $var wire 4 F memory[6] [3:0] $end
   $var wire 4 G memory[7] [3:0] $end
   $var wire 4 H memory[8] [3:0] $end
   $var wire 4 I memory[9] [3:0] $end
   $var wire 4 J memory[10] [3:0] $end
   $var wire 4 K memory[11] [3:0] $end
   $var wire 4 L memory[12] [3:0] $end
   $var wire 4 M memory[13] [3:0] $end
   $var wire 4 N memory[14] [3:0] $end
   $var wire 4 O memory[15] [3:0] $end
   $var wire 4 P memory[16] [3:0] $end
   $var wire 4 Q memory[17] [3:0] $end
   $var wire 4 R memory[18] [3:0] $end
   $var wire 4 S memory[19] [3:0] $end
   $var wire 4 T memory[20] [3:0] $end
   $var wire 4 U memory[21] [3:0] $end
   $var wire 4 V memory[22] [3:0] $end
   $var wire 4 W memory[23] [3:0] $end
   $var wire 4 X memory[24] [3:0] $end
   $var wire 4 Y memory[25] [3:0] $end
   $var wire 4 Z memory[26] [3:0] $end
   $var wire 4 [ memory[27] [3:0] $end
   $var wire 4 \ memory[28] [3:0] $end
   $var wire 4 ] memory[29] [3:0] $end
   $var wire 4 ^ memory[30] [3:0] $end
   $var wire 4 _ memory[31] [3:0] $end
   $var wire 5 $ address [4:0] $end
  $upscope $end
  $scope module wide_narrow_calc $end
   $var wire 32 ) DATA_WIDTH [31:0] $end
   $var wire 32 ( NUM_ELEMENTS [31:0] $end
   $var wire 1 & clk $end
   $var wire 1 ' reset $end
   $var wire 32 ` ADDR_WIDTH [31:0] $end
   $var wire 32 + TOTAL_BITS [31:0] $end
   $var wire 32 a MAX_VALUE [31:0] $end
   $var wire 32 * HALF_ELEMENTS [31:0] $end
   $var wire 16 b memory[0] [15:0] $end
   $var wire 16 c memory[1] [15:0] $end
   $var wire 16 d memory[2] [15:0] $end
   $var wire 16 e memory[3] [15:0] $end
   $var wire 16 f memory[4] [15:0] $end
   $var wire 16 g memory[5] [15:0] $end
   $var wire 16 h memory[6] [15:0] $end
   $var wire 16 i memory[7] [15:0] $end
   $var wire 3 % address [2:0] $end
  $upscope $end
 $upscope $end
$enddefinitions $end


#0
b0000 #
b00000 $
b000 %
0&
1'
b00000000000000000000000000001000 (
b00000000000000000000000000010000 )
b00000000000000000000000000000100 *
b00000000000000000000000010000000 +
b00000000000000000000000011111111 ,
b00000000 -
b00000000 .
b00000000 /
b00000000 0
b00000000 1
b00000000 2
b00000000 3
b00000000 4
b00000000 5
b00000000 6
b00000000 7
b00000000 8
b00000000 9
b00000000 :
b00000000 ;
b00000000 <
b00000000000000000000000000100000 =
b00000000000000000000000000000101 >
b00000000000000000000000000001111 ?
b0000 @
b0000 A
b0000 B
b0000 C
b0000 D
b0000 E
b0000 F
b0000 G
b0000 H
b0000 I
b0000 J
b0000 K
b0000 L
b0000 M
b0000 N
b0000 O
b0000 P
b0000 Q
b0000 R
b0000 S
b0000 T
b0000 U
b0000 V
b0000 W
b0000 X
b0000 Y
b0000 Z
b0000 [
b0000 \
b0000 ]
b0000 ^
b0000 _
b00000000000000000000000000000011 `
b00000000000000001111111111111111 a
b0000000000000000 b
b0000000000000000 c
b0000000000000000 d
b0000000000000000 e
b0000000000000000 f
b0000000000000000 g
b0000000000000000 h
b0000000000000000 i
#5
1&
#10
0&
0'
#15
b0001 #
b00001 $
b001 %
1&
#20
0&
#25
b0010 #
b00010 $
b010 %
1&
#30
0&
#35
b0011 #
b00011 $
b011 %
1&
#40
0&
#45
b0100 #
b00100 $
b100 %
1&
#50
0&
#55
b0101 #
b00101 $
b101 %
1&
#60
0&
#65
b0110 #
b00110 $
b110 %
1&
#70
0&
#75
b0111 #
b00111 $
b111 %
1&
#80
0&
#85
b1000 #
b01000 $
b000 %
1&
#90
0&
#95
b1001 #
b01001 $
b001 %
1&
#100
0&
#105
b1010 #
b01010 $
b010 %
1&
#110
0&
